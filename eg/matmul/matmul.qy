type Matrix = (
    data: MutArrayBox[F32],
    rows: I64,
    cols: I64
);

def matrix (r: I64, c: I64) = (
    new Matrix(new MutArrayBox[F32](r * c), r, c)
);

def matrix_index (m, ir, ic) = (
    // NOTE: all matrices store indices in COLUMN MAJOR format
    ic * m.rows + ir
);
def matrix_ptr (m: Ptr[Matrix], ir, ic) = (
    m.data.ptr(matrix_index(m, ir, ic))
);
def matrix_get (m: Ptr[Matrix], ir, ic) = (
    *matrix_ptr(m, ir, ic)
);

def print_matrix (m: Ptr[Matrix]) = do {
    val i = push mut 0L;
    
    val ss = push new_string_stream(default_heap_allocator);
    while (*i < m.rows) do {
        val prefix_sv = if (*i == 0L) {
            to_string_view(push "[")
        } else {
            to_string_view(push " ")
        };
        string_stream_push_string_view(ss, prefix_sv);

        val j = push mut 0L;    
        file_print(file_stdout, "[");
        while (*j < m.cols) do {
            string_stream_push_number_f32(ss, matrix_get(m, *i, *j), 10, 0);
            if (*j < m.cols - 1L) {
                file_print(file_stdout, ", ");
            };
            j := 1L + *j;
        };
        file_print(file_stdout, "]");

        if (*i == m.rows-1L) {
            file_print(file_stdout, "]\n");
        } else {
            file_print(file_stdout, "\n");
        };

        i := 1L + *i;
    };
};

def main () = do {
    file_print(file_stdout, "2D Matrices!\n");
    val rows = 2L;
    val cols = 4L;
    val m = push new Matrix(
        new MutArrayBox[F32](rows * cols),
        rows, cols
    );
    print_matrix(m);
    0
};
