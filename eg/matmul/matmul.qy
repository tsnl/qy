type Matrix = (
    data: MutArrayBox[F32],
    rows: I64,
    cols: I64
);

// Not implemented, planned:
// stx matrix (r, c) = do {
//     push Matrix(new MutArrayBox[F32](r * c), r, c)
// };

def matrix_index (m, ir, ic) = do {
    // NOTE: all matrices store indices in COLUMN MAJOR format
    ic * m.rows + ir
};
def matrix_ptr(m: Ptr[Matrix], ir, ic) = do {
    m.data.ptr(matrix_index(m, ir, ic))
};
def matrix_get(m: Ptr[Matrix], ir, ic) = do {
    *matrix_ptr(m, ir, ic)
};

def print_matrix (m: Ptr[Matrix]) = do {
    val i = push mut I64(0L);
    
    // TODO: string_stream requires an allocator!
    // val ss = new_string_stream(default_allocator);
    while (*i < m.rows) do {
        if (*i == 0L) {
            file_print(file_stdout, "[");
        } else {
            file_print(file_stdout, " ");
        };

        val j = push mut I64(0L);    
        file_print(file_stdout, "[");
        while (*j < m.cols) do {
            // TODO: write to a StringStream instead, then print all at once.
            val v = matrix_get(m, *i, *j);

            file_print(file_stdout, "#");
            if (*j < m.cols - 1L) {
                file_print(file_stdout, ", ");
            };
            j := 1L + *j;
        };
        file_print(file_stdout, "]");
        
        if (*i == m.rows-1L) {
            file_print(file_stdout, "]\n");
        } else {
            file_print(file_stdout, "\n");
        };

        i := 1L + *i;
    };
};

def main () = do {
    file_print(file_stdout, "2D Matrices!\n");
    val rows = 2L;
    val cols = 4L;
    val m = push Matrix(
        new MutArrayBox[F32](rows * cols),
        rows, cols
    );
    print_matrix(m);
    0
};
