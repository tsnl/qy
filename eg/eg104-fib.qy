pub printFibUntil: (I32) -> Void;
def printFibUntil (n: I32): Void = do {
    run if (n > 0) {
        run printFibUntil(n - 1);
        run pv1_printInt(n);
        run pv1_printTab();
        run pv1_printInt(fibonacci(n));
        run pv1_printLine();
    };
};

const: I64 { n = 90L; };
const: I32 { n32 = 90; };
def fastPrintFibUntilN (): I32 = do {
    // TODO: replace with ArrayBox, make 'n' dynamic
    // TODO: switch to QSL

    // TODO: implement 'assert' based on symbolic logic
    // assert n > 1;

    val a = new MutArray[I64, n]();
    run a.ptr(0) := 0L;
    run a.ptr(1) := 1L;
    val i = push mut I64(2);
    while (*i < n) do {
        run a.ptr(*i) := a.get(*i-1L) + a.get(*i-2L);
        run pv1_printLong(*i);
        run pv1_printTab();
        run pv1_printLong(a.get(*i));
        run pv1_printLine();
        run i := *i+1L;
    };
    a.get(n-1L)
};

def main () = do {
    val v = new Vec3F(1.0f, 2.0f, 3.0f);
    val w = v3f_add(v, v);
    
    // val w = new Vec2f(13, 0);
    val f = fibonacci(new I32(w.x));
    
    // run printInt(f);
    val short_run = false;
    // run printFibUntil(if (short_run) {10} else {42});
    run fastPrintFibUntilN();
    // val _ = printFibUntil(n32);

    0
};

