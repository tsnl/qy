Stage I Program flow: using interpreter
-   While statements left to read,
    -   interpreter reads a statement from the parser.
    -   interpreter evaluates statement, updating `types`, `interp`.
    -   `lambda` is compiled to LLVM IR lazily, transformed into a closure object
    -   `struct` and `union` must be evaluated at compile-time, objects used to bake LLVM IR.
-   Interpreter looks for 'main' function in memory, runs it
-   Exit

Stage II Program flow: using LLVM
-   Initialize the JIT with hooks to the compiler to create types,
    functions from existing type objects.
-   While statements left to read,
    -   compile each statement to LLVM, referencing embedded calls above
-   Run 'loading' phase, during which types may mutate.
-   Run 'analysis' phase, during which we perform inference.
-   Run 'emit' phase, generating optimal LLVM IR as binary.
-   (Optional) run 'exec' phase, running generated LLVM IR.
-   exit
