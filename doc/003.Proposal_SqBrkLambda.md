Reason: 
-   this is a vital feature for achieving good performance: without this, lambdas must be constructed from runtime args,
    and we will have to bake a function every time we instantiate a lambda in code.

    Even with caching, this is unacceptably slow.

    Hence, we need this feature.

Feature:
-   Use `[...] => {...}` to define template function objects.
-   When invoked, these template functions are **evaluated at the same time as the enclosing lambda.**
    -   This makes these functions impossible to evaluate after load-time.
-   When invoked, these template arguments can only rely on known constants, e.g.
    -   variables bound in previous statements
    -   other `[...]` function calls
    -   literals
    -   bound symbols by `[...]` function calls
-   These are regular objects.

Downsides:
-   it is confusing to the user, and requires maintaining additional state
-   it compromises a design goal, which is to be able to parse a data-type from a file/schema/IDL file
    -   we can parse this data into a data-structure
    -   but we would then rely on the constant value of this data-structure embedded within constant args
    -   still possible to make fancier factories at higher-level
-   creating these 'at run time' is no less efficient _when used correctly_ and is more flexible.
    -   just need to encourage the user to cache results instead of expecting PL to do it.
    -   treating type instantiations as separate instances/leaning into nominal type system forces the user to do this naturally.

```
// Q4 enables creative programming APIs by allowing types to be first-class objects in an efficient runtime environment.

// This document covers `[...] => {...}` lambdas, which are used for templates at load-time.
// We NEED these to ensure certain functions are only evaluated at load-time.

// However, since they introduce significant complexity, I propose they be pushed to a future update.
// Instead, like Go, version 1 should focus on robustly supporting 'any' and interfaces.
// However, several insights can be gleaned about behavior.

// Use '[...] => {...}' lambdas to always evaluate at load-time.
// - These lambdas are bound like regular lambdas.
// - When invoked, we use the args to produce a **cached** instantiation of the body
//   - this is just like templates in C++, but anonymized
//   - []-args must be one of...
//     - a bound []-lambda formal argument
//     - a global symbol bound in a prior statement (whose value is hence known)
//     - another []-lambda call
//     - a simple literal/constant
// - KEY: no new instantiations occur after load-time
//   - simply no new lines of code
// PIVOT: stick to C/C++ type system.
// - use pointer tagging to reserve special lambda, type, and template/macro-lambda 
// - manual memory management through and through with C++-style constructor/destructor messages
// - note: arrays lookup just like functions: they map integers to values.
// - note: applies to type signatures too: messages now accept [this] or [mut this]

Vector = [T: IType] => struct {x: T, y: T};
vec2f = (x: Float32, y: Float32) => { Vector[Float32]{x, y} };      // Vector[Float32] evaluated with the closure
vec2 = [T: IType] => (x: T, y: T) => { Vector[T](x, y) };           // Vector[T] cannot be evaluated, but can wait for T, a [bound] var, so OK
bad1 = (T: IType) => (x: T, y: T) => { Vector[T](x, y) };           // broken: expect 'T' at compile-time for formal args, 'Vector' call
bad1 = (T: IType) => (x: T, y: T) => { Vector(T)(x, y) };           // broken: expect 'T' at compile time for formal args
oops = (T: IType) => (x: IAny, y: IAny) => { DefinedFn(T)(x, y); }  // may compile! but no type instantiation possible.

v1 = vec2f(0.0f, 1.0f);
v2 = Vec2f{42.0f, 0.0f};
v3 = vec2[Float32](0.0f, 1.0f);
array = Array[Float32]{1.0f, 2.0f, 3.0f, 4.0f};
array(0) == 1.0f;
array(1) == 2.0f;
array(2) == 3.0f;
array(3) == 4.0f;
```
