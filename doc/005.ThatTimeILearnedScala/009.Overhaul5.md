# 009.Overhaul5

The previous approaches get one thing right: rather than find an orthogonal model of data, we want a model that
makes it efficient to write code.

IDEA: embrace the philosophy of Scala, but not the mechanisms: need a simpler language to implement successfully.
-   how can we leverage inference solves to help the programmer write code?
    -   overloaded macros are a big example, overloading in general
    -   implicit constructors can do a lot of heavy lifting, allow us to mask methods behind classes
    -   can use closures in classes to capture arbitrary fields as required
-   how can we implement subtyping efficiently and intuitively?
    -   IDEA: (from JAI) combine `using` with composition over inheritance for dynamic member lookups
    -   IDEA: what about `implicit super`?
        -   any field marked `implicit super` (or maybe just `super`) may implicitly replace the whole value
        -   this can even eliminate explicit dynamic dispatch, since this can be used to synthesize and access v-tables...

DESIGN
-   the user only defines structs, classes (modeled on structs), variants (optionally discriminated unions), and modules (static objects), and subclasses.
    -   class definitions analyze the closure to determine members, fields, initializer, etc.
    -   subtypes are our solution to aliasing and polymorphism
        -   anonymous subtypes: great for ad-hoc method injection, passing multiple lambdas to something
        -   named subtypes: like type aliases.
-   subclasses cannot admit any new data members, but are fully covariance-generics-compatible with ancestor types.
-   no templates at for initial prototype, but straightforward enough to add.
-   support pointers, manual memory management, strict immutability

SYNTAX
-   allow arbitrary operator characters in identifier names
-   allow binary identifier operators of lowest precedence to desugar like in Scala

```
struct Vec2f { x: f32, y: f32 };

abstract Animal (name: String, desc: String) {
    def sound_name: String;
    def color(variant_ix: i32): String;

    def observe(): String = {
        msg = StringBuilder.new();
        sound_name
    }
};
subclass Frog extends Animal("frog", "a tiny reptile with a big voice") {
    def sound_name = 
}
```

ABANDONED for the true right prototype