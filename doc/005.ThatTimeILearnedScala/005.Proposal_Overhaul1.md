# 005.Proposal_Overhaul1

Modelling all types as first class objects has several disadvantages, the main one being that things are confusing.
Instead, we want types to be built-ins, with the option to use first-class values constructed from builtin types as higher-order types.

Boxed classes are useful for polymorphism because we can pre-compute and bind the V-table without much effort.
When all objects are boxed, it does not matter what the underlying data is for function definitions, but subclasses can reuse superclass code.

IDEA:

(later)
rather than classes, named implementations?
-   generic functions that satisfy an interface given a previous interface, like a function
-   can be used with interface system to automate a lot of work
-   interface instances can be ref-counted
-   still no pointers, no mutability without interface instances.
    -   highly functional design! means the only way to write effects is by calling a mutable interface method.

CONSIDER switch to Swift/Java-based model, moving away from 'everything is data'
-   allow the user to define types (struct, union, enum, interface, ~~class~~) at the top-level
    -   FIXME: use named implementations instead of classes
    -   only class INSTANCES may accept methods via dynamic dispatch (halves the size of an 'any' pointer)
        -   this approach makes DD, when used, more efficient.
        -   since classes are boxed anyway, classes use single-inheritance + a single data member.
        -   instances are immutable and non-nullable by default
            -   default: non-nullable to specify nullable, use `Opt` enum
            -   default: immutable, use `mut` postfix
            -   e.g. of nullable, mutable: `Opt<mut CType>`
        -   methods can still be defined for primitives, but never invoked via dynamic dispatch
        -   consider allowing methods and constructors to be used via UFCS such that `0.T` == `T(0)`
            -   arbitrary functions can be invoked using method-call style for primitives and objects alike
            -   methods take precedence over promoting a static function to act like a method (determined by type)
            -   types must also be registered as functions for construction to work this way.
                -   eliminate need for casting syntax
        -   NOTE: all methods that mutate their objects _must_ be declared and used with a `mut` suffix
            -   thus, all mutable type specs: `mut T`
    -   only classes use reference counting
        -   use `v: T` to indicate a strong reference, and `v: &T` to indicate a weak/borrowed reference
        -   can check for cycles at compile-time, though this does not guarantee no cycles at run-time.
        -   reference counting is a relatively costly GC approach, but produces a huge in improvement in quality of life.
    -   `enum` definitions produce discriminated unions or unlabeled discriminated constants.
    -   these types can only be defined/instantiated in the top-level.
-   allow the user to define functions and values at the top level.
-   introduce a more traditional template generics system (the user understands how this works, is vital)
    -   functions can accept a mix of template and non-template args, or just one or the other.
    -   closures no longer take type parameters: save it for `def` statements for functions, infer within scope.
    -   use `[v: T]` for values, `[T: An ICond]` for types satisfying an interface (interface types always start with 'I')
-   allow `mut` signatures to denote methods
    -   may not be required after UFCS switch
-   remove
    -   templates as first class objects
    -   basic types as first-class objects
    -   arrays as first-class objects

```
exports {
    Vec, fibonacci
}

def Vec2 <T: An IFieldAdd> = struct { x: T, y: T };
def Vec3 <T: An IFieldAdd> = struct { x, y, z: T };
def Vec = enum { 
    V2 (Vec2), 
    V3 (Vec3), 
    PosUV (Vec3, Vec2) 
};

def fibonacci <T: An INumber> (x: T): T = {
    if (x < 0.T) {
        0
    } else if (x == 0.T or x == 1.T) {
        x
    } else {
        f1(x - 1.T) + f1(x - 2.T)
    }
};

def IVector <T: An IScalar, v: i32> = interface {
    # describe the signatures of methods
    # NOTE: 'This' is a keyword
    mut add_in_place: (This) -> void;
    mut scale_in_place: (T) -> void;
};
def IVector3f = IVector<f32, 3>;

#
# all functions are defined like this:
#

def add_in_place (this: mut IVector3f) (other: IVector3f) -> void = {

};

# by supporting currying using this syntax, we can make UFCS functions work easily using closures instead of V-tables.
def add_f32 (self: f32) (other: f32) -> f32 = {
    
};
def add_v3f_inplace (self: mut IVector3f) (other: IVector3f) -> void = {
    self.add_in_place(other)
};

# Thus, user just defines UFCS functions. 
# When constructing an interface instance, we perform a compile-time lookup and application to construct a v-table for the instance.
def data = Vec3<f32>(1, 1, 1);
def obj = IVector3f(data);      # creates a reference-counted 'instance' of the interface: require 'data' to support all of the interface's methods in UFCS form.
def summand = Vec3<f32>(0, 0, 0);
def summand_obj = IVector3f(summand);   # same as above
# the following two statements are equivalent.
add_v3f_inplace(obj)(summand_obj);
obj.add_v3f_inplace(summand_obj);
# NOTE: this is fake currying, since curried functions must be applied all-at-once-- use lambdas to explicitly curry.
#   -   improves efficiency of generated code by a lot
#   -   helps us catch programming errors more easily

# Arrays, slices:
def PosPool = Array<mut Vector3f, 64*64>;
def PosList = Slice<mut Vector3f>;
```
