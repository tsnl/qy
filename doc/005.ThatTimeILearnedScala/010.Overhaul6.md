# 010.Overhaul6

Turns out, I don't need to turn Qy into a Scala, I just need to borrow implicits to allow modules to act as types.

In a past version of Qy (maybe Qy 1 IIRC, I had the following setup)

```
mod module1 [...] {
    mod module2 [...] {
        // totally static bindings
    };
};
```

Observe that a class is simply the span in feature-space covered by 
-   per-object data
-   a supporting static namespace containing symbols.

IDEA: what if `implicit` used to allow modules to _behave_ like types or values?
-   a single field is marked `implicit`
-   can be used to collapse functionality up from several modules
-   if module name is basically the type name, then this is exactly like 'reaching into' the type for static members.

This past version did not offer or plan any support for dynamic polymorphism.
My plan was to implement interfaces in user-space, which can be done, but is not very efficient.
Instead, integrate interfaces and implementations into this scheme using classes
-   in Q4, classes are types that take only one parameter, an instance of the supertype.
-   the user can only define single-dispatch methods in classes, no data members
-   in Q4, each subclass always has the same size and data layout as their superclass
-   in Q4, it is possible to define anonymous subclasses (much like in Scala)

```
mod Vec [T Any, const n i32] {
    # implicit fields will be used when `Vec` alone is used, depending on context and type required.
    #   - special 'types' for implicit: 'type', meaning in type contexts.
    #   - otherwise: parse user type, resolve overloads and select this type.
    #   - think of 'Vec' as an 'overloaded object'
    # NOTE: this is separate from Scala's implicit parameters, and separate from our own implicit class (constructor).
    implicit type = Data;
    implicit Data = zero;

    trait Vector {
        # abstract declarations:
        # NOTE: must be fully type-specified
        def + (other This) This;
        def * (other T) This;
        val dim: i32;
    };

    # the following two statements are equivalent
    # class Vec2f(val x: f32, val y: f32)
    struct Vec2f (x: f32, y: f32)

    # here's an example of an implicit class: constructors always implicit by default.
    # NOTE: Array[T,n] itself can be an implicit!
    implicit class Data (fill_val: f32) extends Array[T,n](fill_val) with Vector[T] {
        # NOTE: simplification over Scala: types always required for function definitions.
        def + (other This) This = {
            # TODO: implement me!
        };
        def * (other T) This = {
            # TODO: implement me!
        };
        def dim: i32 = n;
    
        # auxiliary constructor overloads:
        def This (): void = {
            This(0);
        };
    };

    val zero = Data(0);
};
mod vec_test [const in_debug_mode: bool] {
    # 'use' just indicates exactly which modules (and submodules) are visible to this one.
    # This is vital to limiting the scope of implicits.
    # 'use' also takes an optional 'if' suffix: its argument must be a constant.
    # NOTE: this takes most of the hard work out of baking generics.
    use Vec[f32,3] if in_debug_mode;
    
    def run_all_vec_tests (): void = {
        const field_count = 3;
        # val zero = Vec;               # -> FAILS, cannot infer parameter list, even if only one monomorph in scope (future proof) (use subclass to shadow)
        val zero1 = Vec[f32,3]();       # -> OK, alias for Vec[f32,3]::Data().
        val zero2: Vec[f32,3] = Vec();  # -> OK, alias for Vec[f32,3]::Data(), inferred parameter list
        val zero = zero1;
        val one1 = zero + Vec(1);       # -> OK, alias for zero + Vec[f32,3]::Data(1), note that 1->1.0f is another implicit conversion.
        val one2 = zero + 1.0f;         # -> OK, exists an implicit class `Vec::Data` that can convert `1.0f` into the appropriate type.
        # ^--- this is really, really good!

        # use '::' to access fields within a module: indicates you're using the raw module, not any implicit instantiation.
        val other = Vec::Vec2f(0.0f, 1.0f)
    };
};

mod entry_point {
    import vec_test[0];
};
```

What about compile-time evaluation?
Rather than interpreting at compile time, just consider supporting multiple entry-points.
IDEA: Support 'persistent' variables that combine nicely with REST-ful principles to cache computed data efficiently.

This solves two problems at once: the user can store data that survives multiple execution passes, and the user can use the
data to decide which sub-entry-point to use dynamically, in a way that is totally flexible.

TODO: explore object serialization, simple compression.

TODO: read this series, very informative:
-   https://www.artima.com/weblogs/viewpost.jsp?thread=163733
    -   in particular, abstract types make a lot of sense

CRITICISM:
-   if you want to extend an existing class, you must create a subclass and define new methods. This may grow fragmented.
-   object oriented principles kind of hacked on, not truly what 'class' means, more like a way to group methods with objects.
-   what do abstract type members look like?
