# 006 - Overhaul 2

Allowing the user to use values as types != allowing the user to use types as values.
Treating types as first-class values caused lots of complexity.
Simpler to keep types static, but allow the user to supply a value in place of a type/with a type.
-   doesn't throw out establishing compilation techniques: code generation will be fast.
-   can still use iterative compilation to solve for values of constants
-   make template evaluation explicit, with the caching this inheres.

This data-model is largely based on Rust and Go, with an emphasis on UFCS and function overloading for DSLs
-   key new idea: UFCS, or uniform function call syntax
    -   this works because the user builds the program space up independent piece by piece.
    -   the user defines _overloadable_ top-level functions
        -   includes operators, custom operators
    -   `.` used to get 'data members' and 'behavior members', latter simply invokes function with UFCS.
        -   functions accept multiple groups of arguments, looks like calling multiple functions at once (e.g. currying) but checked AoT for count
        -   `->` only fills first argument group, letting user specify the remaining
        -   `->` can be chained to parametrize and express complex computation intuitively, e.g. T-diagrams
        -   idea: even template functions/types follow this pattern
            -   e.g. `TraitName.Dyn` == `Dyn[TraitName]`
        -   idea: getters and setters can be described in the same way
            -   builtin getters and setters defined for struct, union, and enum instances
            -   you can extend these easily using functions

        ```
        def add (x i32) (y i32) -> i32 = {
            x + y
        };
        def add (x BigNum) (y BigNum) -> BigNum = {
            x + y
        };
        i = 0;
        n = BigNum(0);
        
        # x1 and x2 are equivalent:
        x1 = i.add(42);
        x2 = add(i)(42);
        y3 = f.add(42.BigNum);
        ```

-   the user defines and binds ADTs at the top-level: 
    -   `struct`, `enum`, `union`: like C, but anonymous
    -   `trait`: doubles as interface and typeclass
        -   provides required behavior member signatures
        -   provides required data member signatures
        -   can be used to qualify template arguments
        -   can be used as a regular type with the `TraitName.Dyn` specifier
    -   NOTE: only `TraitName.Dyn` instances use dynamic dispatch
        -   upon construction, create the vtable and pair with data pointer
        -   upon `.` invocation, use v-table _first_ instead of regular UFCS.
    -   NOTE: native pointers (references) supported, manually memory managed.

### UPDATE 1

CRITICISM

-   QUESTION: how to make this work for defining (possibly static) type messages?
    -   e.g. constructors, destructors, customizing these
-   QUESTION: what about object-oriented approach?
    -   would make creating DSLs much easier
    -   how does this play with UFCS?

SOLUTION

Remove UFCS, instead force 2-arg functions to act as message definitions (i.e. must use `a.b(c...)` syntax)
-   Just like Go
-   This is the better looking option anyway
-   TODO: allow methods with 0 arguments to be specified as well

Approach this with an 'everything is an object' approach
-   interfaces act as dynamic base classes
-   the user defines messages for specific types.
    -   e.g. constructor, destructor for a type.

CRITICISM
-   still, no way to define a constructor, destructor for a 'trait' instance
    -   need a more old-school inheritance hierarchy, or at least explicit abstract base class nodes
    -   alternatively, allow 'trait' instances to have methods defined for such an ABC
-   need special syntax to separate

    ```
    def static_function (x) = v;
    ```

    from

    ```
    def method_function dyn(x) = v
    ```

    from 

    ```
    def method_function_explicitly_called (x) () = v
    ```