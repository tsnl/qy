# 007.Overhaul3

> I've been learning Scala at work. This is my design for a language based on my findings.
> TLDR: orthogonality has been a false lure since the start.

In this language, every value is an 'object', capable of being invoked with certain messages.

The user only defines interfaces, classes, structs, unions, and enums at the top-level.
-   class instances are like structs, and may be copied by value or reference (very similar to C++)
-   static functionality achieved via `object Name {...}` (cf Scala)
-   methods are only defined within class instances
-   **users may _either_ subclass one type _or_ define new data members**
    -   thus, all subclasses always have the same size and data layout, but may have different behavior on dispatch.
    -   thus, **the user can pack instances of a base class together in memory.**
    -   classes may implement as many interfaces as they like.
    -   certain classes may be marked as abstract.
    -   use templates to configure the base type to fit any derived types.
-   for more traditional boxed dynamic dispatch, use `&IWhatever`-- it is impossible to instantiate an interface,
    we can only use pointers to class instances that satisfy the interface.
-   everything is a class instance, including primitives like 'int' or 'float'
    -   simply subclass, define new methods, and pass subclass to 'int' or 'float' instances
    -   downcasting is guaranteed to be a 0-cost operation

Message passing is core to this language.
-   used for manual memory management (constructors and destructors)
-   used for operators, operator overloading
    -   crucial for DSLs, cf Scala
-   used as an abstraction mechanism, e.g. interfaces

Template evaluation is key to this language.

Something new: compile-time evaluation.
-   statements 'evaluated' one at a time
    -   instantiate templates, execute, update environment, continue

Overloading will help a lot.

```
struct Pt {
    x: float32,
    y: float64
}

interface IPolygon {
    area(): f32
}
class Polygon [n: i32] (val pts: Array[Pt, n]) {
    # after loading this statement, ensure these checks pass.
    implements IPolygon

    # can define methods here: no static methods, use 'def'
    def area (): f32 = {
        # todo: general area algorithm
    }
}

class AAB (length: f32, breadth: f32, offset: Pt) {
    subclasses Polygon[4]({
        val pts = Array[Pt, 4] {
            Pt(offset.x,          offset.y), 
            Pt(offset.x + length, offset.y), 
            Pt(offset.x + length, offset.y + breadth), 
            Pt(offset.x + 0,      offset.y + breadth), 
        }
        pts
    })

    # 'constructor' is the function invoked when `AAB` is invoked.
    # NOTE: constructor does not need to return the object type.
    #   can also return 'Opt' or anything else.
    def constructor (length: f32, breadth: f32): AAB = {
        AAB(length, breadth, Pt(0, 0))
    }
}
class Triangle (val p1: Pt, val p2: Pt, val p3: Pt) {
    subclasses Polygon[3](Array[Pt,4]{p1,p2,p3,p4})
    implements IPolygon

    # ...
}

object Methods {
    # implements ISomething;

    def compute_area (v: &IPolygon): f32 = {
        v.area()
    }
}

Tests = object {
    val rect = Rectangle(1, 1)
    val triangle = Triangle(Pt(0, 2), Pt(0, 0), Pt(2, 0))
    val a1 = compute_area(&rect)
    val a2 = compute_area(&triangle)
    assert a1 == a2         # evaluated at compile-time!
}
```

Misc notes:
-   lambdas stay as is, as do function type specifiers.
-   no more semicolons: use leading keyword + parentheses.
-   CONSIDER: use `call(_)` to indicate function handle (cf Scala, Ruby may have a similar mechanism too)
-   TODO: add arbitrary binary operators of lowest precedence.
-   TODO: automatic subclass inference
    -   e.g. if I invoke `1.U`, I must automatically convert '1' using a class with 'U' as a method.

---

Review 1:
-   learning more Scala; discovered the power of implicits.
    -   Scala constructors similar to C++ implicit constructors: used for method injection
        -   e.g. `0.U` resolved by implicitly constructing a class with method `U`
        -   typed overloading heavily exploited
    -   the whole idea is that you can give the compiler implicit conversion functions to apply.
    -   my approach does not offer/consider this.
-   Scala really is object oriented
    -   enums provided via `case class` classes.
        -   I provide an explicit 'enum' statement
        -   It makes perfect sense to provide this kind of boxed enum in a JVM landscape, but not natively
    -   static objects are 'companions' for classes of the same type, such that Scala may invoke `.apply` in the companion to construct instances of the class.
        -   my constructors return different types: this is a divergence
-   Scala allows constructing DSLs at the expense of a complex grammar
    -   I'd rather add semicolons _and_ Scala's syntax sugar for unambiguous parsing.
    -   I love the idea of methods having any name.
    -   I love that Scala supports macros.
