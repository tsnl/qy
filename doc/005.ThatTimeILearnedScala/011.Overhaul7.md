I am unhappy with the current design for a number of reasons:
-   Running the user's code at compile-time with inferior performance is a no-go when the user could build separate 
    programs. Instead, focus on easing this process.
-   Language is verbose! Learning Scala showed me how concise, complex code can be very powerful.
-   Language is inextensible! Learning Scala showed me how much better I can do than 'wrap it in macros'.

Instead, focus on user-defined functions, and running them at compile-time with `run` directives.
-   At the top-level, the user...
    -   defines types: structs, unions, variants (discriminated unions), and subtypes (see below)
    -   defines procedures: global, overloadable, and closure-free.
        -   procedure names are pretty unrestrictive: use operators
    -   NO global values: use objects for all state, though static functions are OK.
    -   defines constants: can be used in template parameters, must be computed from simple args or `run` directive
-   Subtypes are the only way to define methods, and are optionally implicit => dynamic casts.
    -   optionally an 'implicit' subtype, else need to construct like regular type
    -   must specify a supertype, cannot specify any additional data-members
    -   rest of body consists of methods
    -   ~~can also define an anonymous subtype with method definitions~~
        -   tricky to instantiate, unhelpful given our constraints
-   Methods must be defined with an implicit `self` variable

    Somewhere on this thread (P2 IIRC)...
    https://www.artima.com/weblogs/viewpost.jsp?thread=163733

    I learned how Scala solves many generic typing problems by playing with the type of `self`
    -   see discussion on abstract classes
    -   If a base class `Animal` has a method `eat` that accepts some type `BaseFood` then a `Cow` may eat a `Fish`.
        Instead, we want the ability to say herbivores only eat plants, carnivores only eat meat, etc.
        In Scala, you'd use an abstract class field that is overridden in `Cow` and `Cat` with `BasePlantFood` and `BaseMeatFood` respectively.
        The crucial part is that **method definitions in traits can be re-targeted to different data-types.**
    -   this can be achieved using templates, not using generics

    I had an issue at work where defining things globally made the whole thing very hard to refactor.
    -   static modules cannot be easily tested, reused
    -   cannot be checked against interfaces
    I now agree that things should be object-based, despite the performance penalty (additional param) this entails.
    Thus, no static/global functions are permitted.

```
# verifying field properties for Scalar and Vector:
trait Scalar T with Destructible {
    # NOTE: 'This' is the 'trait' type here. Use 'T' to reference the type that satisfies the trait.
    # NOTE: constructors cannot be described: try an abstract static method instead.
    def * (v: T): T :: symmetric;
    def + (v: T): T :: symmetric;

    def scale (v: T): T = this * v;
    def offset (v: T): T = this + v;
};
trait Vector T with ArrayLike with Scalar {
    # 0-parameter functions
    def length_sqr: f32;
    def dim: i32;

    def length: f32 = length_sqr.sqrt;
};
subtype Vec [n: i32, S with Scalar]: Array[n, S] with Vector[S] implicit {
    alias T = S;

    def symmetric * (f: T): This = {
        # NOTE: in the tradition of Qy, array-like returns pointer on indexing, no references
        for (i <- 0 to n) {
            set this(i) = *this(i) * f;
        };
    };
    def symmetric + (v: This): This = {
        for (i <- 0 to n) {
            set this(i) = *this(i) + v(i);
        };
    };
    def dot (v: This): This = {
        # NOTE: in the tradition of Qy, no binds are mutable, use 'push' or 'malloc' to get mut ptr
        val acc = push(0);
        for (i <- 0 to n) {
            set acc = acc + this(i) * v(i);
        };
        acc
    };
    def length_sqr: f32 = {
        this dot this
    };

    # the user can supply destructors and constructors: 
    #   - invoke constructors using postfix {...} call with type as function
    #   - can also implicitly invoke unary constructors
    #     - e.g. primary constructor, takes a supertype instance as an arg, e.g. `This{supertype_instance}`, implicit if class is implicit
    #     - e.g. auxiliary unary constructors defined using 'def implicit constructor'
    #       -   still accessible as explicit constructors
    #   - constructors may return values of any type, e.g. optional or any other monad.
    #     - caveat: implicit constructors MUST return 'This': it's the cornerstone for implicit type conversion.
    def constructor (fill_value: S): This implicit static = {
        # using the primary constructor implicitly
        # Array[n,S]{fill_value}
        This{Array[n,S]{fill_value}}
    };
    def destructor (): void inline = {
        # tear down whatever you want!
        # NOTE: 'inline' definition flag
    };

    # the user can define static methods
    #   - these are just global functions in a special namespace
    #   - these share template arguments with the parent type, though they can define their own
    # this is just a way to keep utility methods organized without a companion object/namespace
    #   - note: these can be abstract in a trait! this is how we can require a constructor interface.
    def hello (): This static = {
        
    };
};

# all the following implicit conversions should work, such that forall i forall j vi = vj
def test_implicits (): void = {
    val v1 = Vec[3,f32]{Array[3,f32]{0.0f, 1.0f, 2.0f}};
    val v2 = Vec[3]{Array[3,f32]{0.0f, 1.0f, 2.0f}};
    val v3 = Vec{Array[3,f32]{0.0f, 1.0f, 2.0f}};
    val v4 = 0.0f + Array[3,f32]{0.0f, 1.0f, 2.0f};
    val v5: Vec = Array{0.0f, 1.0f, 2.0f};
};
def demo_broadcasting (): void = {
    # implicit type conversions let us achieve broadcasting
    val zero = Array[3]{0.0f};
    val ones = Array[3]{1.0f};
    val twos = 1.0f + ones;

    def polynomial (x: Scalar): Scalar = {
        4*x*x + 2*x + x + 0
    };
};

# keep '=>' lambdas with single ID exception since '[x] => {...}' is no more: x => {x.hello}
# NOTE: no type specs in lambdas.
# NOTE: no variadic functions, but very large array initializers are supported (upto function arg count by spec), so use these instead.
```

Ordering: the user may define stuff out of order, we create and check a dependency graph before emitting, constants initialized AoT.

## PLAN

### STAGE 1: monomorphic world

First, get a version working without templates or implicits. 
Focus on getting traits and overloading right. 
Hard-code solutions for basic polymorphic types like pointers and arrays.

Higher-order function like lambdas should be implemented here to ensure the compiler works.

### STAGE 2: implicits

Now, implement implicit classes.
It is crucial to add this complexity before templates since it is tougher to add new features to a more complex codebase.
Implementing templates first may require changing how templates work when adding implicits. Converse not true.

### STAGE 3: implement templates

This is mostly a challenge of scaling things up.

Some compile-time evaluation will be required for constants.

Re `run` blocks, need a 'default' value associated until the run result can be produced, e.g. `run <expression> meanwhile <expression>`.
