Learning Scala taught me so much, I have changed my language goals.
-   complexity is not a bad thing
-   implicits can be very powerful
-   use type inference to solve user problems wherever possible.

Regarding the latter, it's very tempting in Overhaul7 to define subtypes that are basically refinement types.
-   casting to a subtype is the same as refinement
-   use the constructor to 'assert', then run CFA to check that no assertions may fail at runtime?

IDEA: use a vastly simplified type system with refinement types
-   use `T` is a value type (struct, union, variant, ...), `Box[T]` for single pointers and `Slice[T]` for ranges
    -   of course, these two types are refinements of the base `ptr` type
-   by reducing complexity of manifestly typed data, 
    -   we make type solver simpler (and hence more likely to succeed), easier for user to understand.
    -   we shift most typing to latent checks verified by proof

Such a language would truly bridge the gap between manifestly and latently typed programming languages.
-   TODO: learn about Liquid types.
    -   see [Principles and Applications of Refinement Types](principles_and_applications.pdf)
    -   see [Learning Refinement Types](learning_refinement_types.pdf)
    -   see: [Liquid Types](liquid_types.pdf)
    -   see: [Liquid Types (Video)](https://www.youtube.com/watch?v=DHhmBiTInvc&ab_channel=UWVideo)
        -   only works on immutable values
    -   see: [Refinement Types for TypeScript](refinement_types_for_typescript.pdf)
-   TODO: think about encoding a simple type system using liquid types
    -   store as much as possible latently rather than manifestly
    -   use inference + implicit conversion to 'do the user's heavy lifting'
    -   use these properties to guarantee memory safety.