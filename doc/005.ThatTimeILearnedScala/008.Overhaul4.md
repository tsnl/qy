# 008.Overhaul4

GOALS:
-   simple: few gotchas or rules to remember, intuitive to use, hard to make mistakes.
    -   think Python or Lisp, not Scala
-   extensible: I want to convert any and all data/config/build to language source code.
    -   Lisp, Scala, and Python allow the user to express DSLs that can interoperate.
        -   consider: macros
        -   consider: metatyping
        -   consider: compile-time evaluation, templates, implicit casts
            -   Scala does a marvelous job at letting the user declaratively extend the compiler's 
                behavior.
    -   When and how this stuff is evaluated is relative
        -   compile-time and interpretation are equivalent: just different kinds of evaluation
        -   rather than try to reinvent types, try to allow the user to compute stuff in more places.
        -   expand compilation to target different objects
-   fast: use manual memory management
    -   C++ is the best example of a language that is expressive and fast.
    -   explicit control over memory management is vital to a lot of stuff
    -   explicit memory management is often simpler than automatic memory management, easier to identify failures/leaks.

OBSERVATION:
-   by making everything an object, Scala gives you a single interface for type modification: the 'class'

APPROACH: emphasize message passing, but not object orientation.
-   model of the world: several fixed, static constants, like
    -   types
    -   global variable pointers
    -   global function pointers
-   overloaded single-dispatch messages can be defined, as well as static functions.
-   at the top level, the user defines...
    -   traits
        -   union of typeclasses and interfaces
        -   used to qualify both types and values, but in different ways
        -   can include methods or 0-argument methods (that are trivially optimizable once inlined)
    -   modules
        -   like Scala's `object`, can even implement methods (i.e. static functions).
        -   treated as a singleton instance of an anonymous class.
    -   classes
        -   caveat: all subclasses must have the same size and data-layout as their superclass.
        -   layout exactly like a 'struct' in C++
        -   implicit class conversions are an excellent way to achieve
            -   refinement typing checks
            -   method grouping: all defs 'endowed' in one class
            -   extensibility: just extend a builtin type (as though it were boxed) to add functionality

                cf Chisel `1.U`
        -   methods can only be defined within classes
-   at compile-time
    -   compile and evaluate line-by-line, such that global constants defined in previous lines are known.
        -   import like Python, cached per-file.
        -   simplifies template evaluation enormously
    -   permit shadowing of global definitions
        -   this is excellent for overriding old releases, specific version selection
    -   permit implicit constructors, overloads
        -   detect conflicts, raise errors.
    -   resolve syntactic sugar for method references/operators
        -   we detect an ID or an operator used as a lowest-precedence binary operator as a custom operator method call
-   at run-time
    -   trait instances implemented like `std::any` in C++
    -   can pass any subclass in lieu of superclass (not just by pointer, like in C++)

NEW SYNTAX
-   allow 0-parameter calls
-   use `_` to indicate a lambda
    -   together: `Hello(_)`
-   semicolons are back in full force
-   use `as[T]` method to cast, including dynamic cast

```
trait IVector [T: IAny] {
    def scale (scalar: T);
};
trait FVector with IVector[f32] {
    def length_sqr: f32;
    def length: f32 = { sqrt(this.length_sqr) };
};
class Vec2f (var x: f32, var y: f32) with FVector {
    def length_sqr: f32 = {
        this dot this
    };
    
    def dot (other: Vec2f): Vec2f = Vec2f(
        this.x + other.x,
        this.y + other.y
    );

    def scale (scalar: f32) = {
        this.x *= scalar;
        this.y *= scalar;
    };
};
class Vec3f (x: f32, y: f32, z: f32) with FVector {
    // we automatically analyze method closures to infer what data members to keep or discard.
    var m = push(x);
    var m = push(y);

    def this (v2: Vec2f, z: f32) = {
        this(v2.x, v2.y, z)
    }
    
    def length_sqr: f32 = 
        this dot this;

    def dot (other: Vec2f): Vec2f = {
        Vec2f(this.x + other.x, this.y + other.y, this.z + other.z
    );
    def scale (scalar: f32) = {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
    };

    // overloading, type casting:
    def scale (scalar: f32): FVector = {
        this.scale(scalar);
        this.as[FVector]
    };
};
module LinAlg {
    def normalize(v: FVector): FVector = {
        v scale v.length
    };
};
```
