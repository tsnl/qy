## Overhaul_LiquidTypes

Q4 aims to allow the user to build more flexible types using incremental compilation.
The hope was to enable a latently typed language with quality compile-time checks.
Instead of incremental compilation, I have chosen a different way: liquid types.

First, note that the more type information we store latently, the more flexible our code becomes.
-   e.g. type and method data enables duck-typing
-   e.g. reflection on trait properties enables things like abstract type members in classes.
-   e.g. the whole boxed JVM approach to computing: if you're gonna box, may as well inherit from a language-supported base

Finally, this language must be extensible
-   I love languages in which the user writes sublanguages: LISPs are the ultimate example of this, but Scala does an impressive job too, as do languages like Python or Io.

    Philosophically speaking, the art of programming is to write instructions understandable by a computer broken into verbs (functions) and nouns (state).
    Hence, this is true of any language.
    
    By making an extensible language, we allow language users to deploy the same tools in a variety of different environments without paying much cost up-front in hard, builtin features.
    -   hard => hard to implement
    -   hard => unable to modify later: the fewer hard hard decisions [not a typo] we make, the better the language will fare

-   this makes it trivial to interact with data on-disk since programs in DSLs can be executed to load data files from scratch, serialized in binary format for release, and serialized in text to update debug data files.
    -   this makes it easy for external tools to piggyback on the compiler's checking

GOALS: build an extensible language that compiles to native machine code, and that uses liquid types.

IDEA: any memory is an object: we interact with it using messages.
-   All data types are 'value' types, and are immutable by default.

    You can define a mutable variable using the `var` keyword, in which case any `var` fields in the type are enabled.
    -   `var` fields are struct fields that are denoted as explicitly mutable using the `var` keyword rather than the `val` keyword.
    -   in an immutable struct, even `var` fields cannot be mutated. In a mutable struct, only `var` fields can be mutated.
    -   mutable types are denoted by a prefix '!', e.g. `!T`
        -   mutable trait object => 

-   Any `ptr` is returned by `alloc`, which uses compile-time magic to infer if this pointer is local or not.
    -   `alloc` can be a builtin initially, but should try to make it library level so user-defined allocators are easy/intuitive
    -   `alloc` always allocates EITHER...
        -   an instance of a single element, e.g. `box(t)`
        -   an owned, dynamic slice of memory, e.g. `vec(t)`
    -   for every `alloc`, we must prove there is always a `free`, and that the resource is never used after it is freed or before it is allocated

-   Complex data-types are expressed using predicates on the values stored at memory
    -   C ADTs provided as primitives to build complex in-memory data-structures
    -   E.g. a tagged union can be the first 'project'
    -   E.g. these 'typeschemes' can expand to deal in a safe way with untyped memory buffers
        -   e.g. packets
        -   e.g. binary serialized buffers
        -   e.g. file formats with bounds, magic bits
        -   these are all cases that _no_ existing type system has insight into
    -   E.g. you can 'type a buffer at runtime' by
        -   writing predicates on a buffer indicating whether a buffer contains an instance of a type
        -   writing a type scheme using these functions to define a type
            -   e.g. arbitrary subclassing via boxing like Java/C++ with pointers
            -   if you use a dependent type, you can alter the properties of the type at run-time
                -   e.g. buffer-size
                -   e.g. cache-line-size
        -   parsing buffer into memory, branching off into 'throw' if data is invalid.
            -   compiler checks that your 'type conversion' aka data refinement makes sense
            -   errors detected at compile-time
    
-   how to make dynamic dispatch/DSLs easy?

    IDEA: let traits be flexibly evaluated predicates that qualify types
    -   the user can define 'classes' which are just predicates on memory at a pointer, called 'this'
        -   each trait is denoted by a predicate function
        -   if predicate is true, it tells us...
            -   existence of methods for this type of a certain signature
            -   existence of fields for this type, including type fields
            -   existence of arbitrary properties, including size, layout, etc.
        -   when a predicate is true, the given methods are defined.
            -   methods exist in a special, separate per-trait namespace
            -   methods cannot use any properties not given by the predicate
        -   we can 'infer' the subtyping transition and invoke any initializer code at this time.
    -   requirement that objects be in-memory/accessed by pointer vital for downcasting.
    -   implicit downcasting/upcasting can be used to levy refinements.
    -   this allows us to...
        -   restrict some classes such that all subtypes are fixed size (see 005.011.Overhaul7) or such that
            they work as in Java or Scala, with heap fragmentation galore.
        -   leverage implicit subtyping

THUS
-   re-imagining object-oriented design principles to create a safe super-language of C, Java, Python.
-   simple enough language design


RESOURCES
-   http://goto.ucsd.edu/~ucsdpl-blog/liquidtypes/2015/09/19/liquid-types/#:~:text=Liquid%20Types%20are%20a%20constraint,integer%20linear%2C%20set%20theory%20etc.


PITCH CODE

```
# NOTE: `type` usually refers to functional datatypes: scalars, ADTs, function pointers, `ptr`
# NOTE: 'class' is a subset of a type, used to denote a refinement. We say 'class of a type'
# NOTE: 'typeclass' is a separate entity, used to levy constraints on types.

# 'AnyType' is the builtin root typeclass.
typeclass AnyType { ... };

# T: U <=> T subtypes U
# when defining a typeclass, the argument of the FIRST template param block (can take 2) is called the 'supertypeclass'
typeclass UInt [T: AnyType] { require T == u8 | T == u16 | T == u32 | T == u64 };
typeclass SInt [T: AnyType] { require T == i8 | T == i16 | T == i32 | T == i64 };
typeclass Int [T: UInt + SInt];     # can use '+' and '*' to sum and intersect interfaces

# now, we have a generic refinement type: note that instances aren't interchangeable:
# NOTE: the argument for a class is NOT a constructor, but rather the formal parameter for a class predicate.

Nat [T: Int] (v: T): Bool = { v >= 0; };

# now, we can define a safe fibonacci function:
fibonacci [N: Int] (n: Nat[N]): N = {
    if (n == 0 or n == 1) {
        n
    } else {
        # this might produce overflow issues!
        # fortunately, the compiler will complain about these if and when they occur.
        fibonacci(n-1) + fibonacci(n-2)
    }
}

def main(): i32 = {
    val x = Nat(-1);        # -> produces a compile-time error
    val y = Nat(42);        # -> OK
    0
};

#
# P2: instanced traits
#

class Ptr [T] (v: ptr) { 
    # these are called 'requirements'. They must ALL evaluate to 'true'.
    # these extend formal parameters.
    # note that these must be 'compile-time' checks run in SMT, so you can't use '!' functions here.
    require T @ v;
    
    # 'T.n` is shorthand for **the type of `v.n` in `v: T |- (v.n)`**
    # for now, messages are the only way to achieve closures.
    # NOTE: ':' is a constant operator.
    # NOTE: 'provides' is like 'require' but for after
    provides This.lea: T;
    
    # method definitions
    # NOTE: not possible to anonymously define refinement types: use a trait instead.
    #   - no dependent typing: everything explicit as functions.
    #   - heck, no explicit closures yet, just methods
    def lea: T = {
        # ... ugly code to read raw bits, cast to 'T' value, and return 'T' stored at 'v'
    };

    # NOTE: adding a '!' to method names is required when the method may mutate stuff.
    # NOTE: methods can be called at compile-time!
};

# In C++, we would often like to contiguously pack instances of some base class.
# The problem is that derived types can have a different size than the base type.
# There are three solutions:
# -   build a union ADT containing your variants:
#     - scales poorly
#     - wastes memory for the worst case
# -   box your data, such that you store pointers to instances instead of instances themselves
#     - all these pointers are the same length
#     - poor cache coherence
# -   hybrid of 1 + 2: usually the best approach
# Instead, here, we specify that each derived instance must fit within a base instance.
# -   unions are _removed_, and instead generalized with memory spans of pre-determined size: **`Bytes[n]` that serves as root of all data types.**
#     -   if our approach is to decide the sizes of things and implement types to match, not the other way around, perf improves.
# -   use '?' for value holes: try to get SMT solver to solve for you.
# This is like a pre-allocated union, but is type-safe!

val PAGE_SIZE_IN_BYTES = 64;

struct ActorKey (val id: i32, val flags: i32);
struct BaseActor (val key: ActorKey, val data: Bytes[?]);    # -> short-hand for calculating explicit byte size-- use requirements
require {
    BaseActor.data.size > 0;                # NOTE: BaseActor.data returns a type!!
    size(BaseActor) == PAGE_SIZE_IN_BYTES;  # NOTE: 'size' is a builtin operator that generates a message for objects aka memory
};

typeclass ActorExtType [T] {
    require T.size <= BaseActor.data.size
};

# the user can write types that satisfy the 'ActorData' trait, or create traits of their own that subtype this trait.
# note that traits are the only way to define methods.

# now, the magic:
struct GenericActor [ExtType: ActorExtType] (val key: ActorKey, val ext: ExtType);
class Actor [ExtType: ActorExtType] (v: GenericActor[ExtType]) {
    # one of many examples of explicit refinement
    def data: Ptr[ExtType] = {
        Ptr[ExtType](&v.ext)
    };
};
def actor [DataType: ActorData] (key: ActorKey, data: Ptr[DataType]): BaseActor {
    require size_of(Actor[DataType]) <= size_of(BaseActor);
    var a = push BaseActor;
    &a.key := key;
    memcpy(&a.data, data, size_of(DataType));   # we have proven that this operation will succeed given inferred bounds
    a.lea       # -> remember, from earlier?
};

# Ta-da!
# ... (more code, building support for variadic templates)
typedef PlayerActor = Actor[struct{ tx: TransformComponent, mesh: RMeshComponent, input: PlayerInputComponent, camera: RCameraComponent }];
typedef EnemyActor = Actor[struct{ tx: TransformComponent, mesh: RMeshComponent, input: AiInputComponent, camera: RCameraComponent }];
def example (): void = {
    val a1 = actor(ActorKey{id: 0, flags: 0}, PlayerActor(...));
    val a2 = actor(ActorKey{id: 1, flags: 0}, EnemyActor(...));

    # now, 'a1' and 'a2' can be packed together arbitrarily, or have common methods defined.
    # to access data, downcast to 'Actor[T]' and invoke the 'data' method
    #   - unlike C++, this is usually 0-cost
    #   - unlike C++, this is safe/verified without std::variant (hmm)
};

#
# P3: mutable types
#

# use '!T' to denote mutable T
class VarPtr [T] {
    require !T @ p
};
```

Thus, classes are duck-inherited at compile-time in a way that is still good to use and flexible.

BUT what about logical quantifiers? 
-   'class' kind of gives us a 'forall', but what about 'exists'
-   what about dependent typing?

NOTE: cannot instantiate a trait directly!
-   this makes the language much less confusing for those from other backgrounds
-   use `Any[TraitName]` instead, with `Any` without args being a shorthand for the universally satisfied trait

TODO: annotate functions for mutability
-   stateful functions must end with '!' suffix, cannot be used in logic
-   '!' is recursive, so you may find a lot of '!' in one place when writing mutators

NOTE: templated traits can get confusing
-   every trait is monomorphic-- we use templates to evaluate _separate_ poly

NOTE: breaking with tradition of Qy, allowing 'var' definitions and '&' unary operator
-   this simplifies local mutability so much... like, so much...
-   'val' and 'var' alike are pushed to the stack, but we don't count effects to the local stack frame OR in sub-scope
    -   if there are no side-effects after a function call concludes, pretend it is pure, even if it wrote to the stack.
    -   some nuances to interpret here...

NOTE: 'class' indicates refinement, 'typeclass' indicates trait/interface/...
-   can span over multiple types that satisfy a **monomorphic typeclass** using an `Any[MonoTc]` instance
    -   similar to `std::any` in C++, `interface{}/any` in Go, `dyn <trait>` in Rust.

LIMITATIONS:
-   no method overloading/shadowing is feasible...
    -   need to associate specific names with specific classes
    -   if two classes define the same method name with different types, this is a compile-time error.
        -   methods may be polymorphic: bundling v-tables will be difficult, but is possible.
-   heavy emphasis on immutability, FP
    -   this does not 'glue well' into existing approaches, though it imposes less than Rust
-   confusing OR verbose: pick your poison
    -   confusing => all classes are implicit, verbose => all classes are explicit
    -   implicit class construction can get... hairy to resolve, though method name limitations help.
    -   IDEA: special 'implicit class' option ameliorates this.

SHORT-TERM PLAN:
-   do not write code yet!
-   keep writing examples, polishing language, and studying.
    -   immutable pointers? They feel strangely redundant...
    -   mutator methods? 

## IMPL

Liquid type inference algorithm runs on a set of logical qualifiers Q
-   first, perform Hindley-Milner type inference
-   second, generate constraints on the templates (liquid type variables that have the same 'shape' as the original variable)
-   third, solve constraints using predicate abstraction to find, for each K, the strongest conjunction of qualifiers that satisfies all constraints Q*

Logical qualifier? a predicate over program variables
-   includes special placeholder '*' to indicate program variables (dependent typing, 'depends' on program state)