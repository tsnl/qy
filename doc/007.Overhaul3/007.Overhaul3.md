# 007.Overhaul3

First, build a very simple, C-like language.
Then, allow the user to use specific unary functions as type specifiers.

## PHASE 1

```
# Use the '#' character to begin a line-comment.
# Identifiers are of 3 types:
# - holes, which do not contain any alphabetical characters, and that must start with a '_'
# - TIDs, where the first alphabet from left to right is uppercase.
# - VIDs, where the first alphabet from left to right is lowercase.
# Use the '=' operator as the universal value binding operator.
# Use the ':=' operator to assign/update a value.

# this is how you define tuples, unions, and struct datatypes:
# - tuples use (exp, exp, ...) or (ts, ts, ...)
# - structs expand this with (id: exp/ts, id: exp/ts, ...). This make optionally named arguments a breeze.
# - unions use the same syntax as structs, but with '{...}' instead of '(...)'
# - 'T = U' can be used to type alias.
# these type definitions can be composed and factored very easily.
FVector = (VecKind, {v2f: Vec2f, v3f: Vec3f}); 
VecKind = ISize;        # better with refinements, see Phase 2
Vec2f = (x: F32, y: F32);
Vec3f = (x: F32, y: F32, z: F32);

# here's how you define functions:
# they need full type specifiers, cannot be overloaded, can be template polymorphic, and templates cannot be specialized by type.
# note that types are constructed by invoking them like functions, though this does not imply any heap allocation.
# note that all functions are fundamentally unary: we use tuple and struct objects to pass many args.
add (v: Vec2f, w: Vec2f) -> Vec2f = Vec2f (v.x + w.x, v.y + w.y);
mul (v: Vec2f, s: F32) -> Vec2f = Vec2f (v.x * s, v.y * s);

# note that pointers are defined with '&T' syntax, dereferenced with '*expr' syntax.
# it is impossible to take a pointer to a stack variable, there is no unary '&' operator, instead, pass pointers around (cf ML).
# the 'v.name' operator is overloaded for 'v' a pointer or an adt.
# memory allocation achieved using `push`, `heap`, and `free`.
```

## PHASE 2

```
# any of the above statements can be combined with templates:
Vec [T: Any, n: I32] = (x: T, y: T);

# typeclasses are unary template predicates over types.
# by convention, they are written in SCREAMING_SNAKE_CASE.
INT [T: Any]: Bit = {
    T <: I8 | T <: I16 | T <: I32 | T <: I64 |
    T <: U8 | T <: U16 | T <: U32 | T <: U64
};
FLOAT [T: ANY]: Bit = { T <: F32 | T <: F64 };
NUMBER [T: Float|Int]: Bit = 1;

# refinement types are just unary functions defined with TIDs instead of VIDs
# by convention, they are written in UpperCamelCase like regular types.
Nat [T: INT] (v: T) -> Bit = { v > 0 };

# template evaluation can use any pure, value-based function.
```

## PHASE 3

```
# closures are defined using `{ arg1, arg2 => ...}` blocks. Note type signatures are optional. Note that any arguments are optional.
# closure types are denoted using the `(argType1, argType2) -> retType` syntax or '-> retType' syntax for IIFEs.
# note that the (*argType) syntax can be used to accept variadic params, and works well with dynamic typeclasses (see below).

# note that `{...}` is now an IIFE, which does not break any of the semantics so far.
# to pass an IIFE lazily, use `expression {...}` postfix-call syntax, where expression takes a function as a unary argument.
# - can figure this out if we treat all function calls as deferred: wait till we have precise function type, then see if we need to evaluate arg.
# - at this point, may be simpler to just use iterative fixed-point method rather than HM.
# - easily optimized via a pre-sorting pass...
# in conjunction with good reflection libraries, this will allow for good DSLs.
vertex_shader () -> GlslShader = glsl.shader {
    instance_id, fragment_id =>

    # NOTE: glsl.Bundle[T] is generic, but T is inferred
    # NOTE: scoped 'using <namespace>' is vital, shadows previous definitions, e.g. Vec3f and Mat4x4
    ubo = Bundle (
        mvp: Bundle (
            model: Mat4x4[f32],
            view: Mat4x4[f32],
            pos: Mat4x4[f32]
        ),
        texture: Texture2dSampler
    );
    io = Bundle (
        pos: Input[Vec3f](),
        normal: Input[Vec3f](),
        uv: Input[Vec3f](),
        out_color: Output[Vec3f]()
    );

    main = function {       # glsl.function invocation
        when (instance_id & 1 == 0) {
            out_color.set(Vec3f::zero);
        }.else_when(other_condition) {
            # ...
        };
    };
};

# currying is also supported since closures are too.
# note that our VID rule works fine with IDs with uppercase letters provided the first is lowercase (common practice).
physicsTransaction [T: Any] (precondition: Bit) (body: -> Void) = {
    # ...
};

# make traits/DD/static methods work:
# -   'dyn <typeclass>' will be a problem since 'typeclass' intentionally supports unions: we want something restricted to just methods.
# -   just copy Rust's approach, but put 'self/&self/&mut self' in a separately curried argument with '<...>' brackets
# -   'Any' is the base trait, so consider making traits dynamically instantiable with the 'Any {...}' syntax
#     - only function definitions, can omit body only in trait body
#     - use 'self' keyword to indicate dynamic method, else static: trait bounds can require static methods.
# -   use 'T -> dyn <trait> {...}' to 'impl'
#     - this is read as 'T implies the dynamic trait <trait> with {...}'
#     - the starting expression is called the 'postcondition check' and is just run after the block as a guard
# -   use 'dyn <trait>' as a type specifier.
Vector [Scalar: FLOAT] = Any {
    new (fill_value: Scalar) -> Vector;
    add (self) (other: Vector) -> Vector;
    mul (self) (other: Scalar) -> Vector;
    at (self) (index: I32) -> Scalar;
    set (&mut self) (index: I32) -> Scalar;
};
Vec3f -> dyn Vector[F32] {
    new (fill_value: F32) -> Vec3f {
        # ...
    };
    add (self) (other: Vector) -> Vector {
        # ...
    };
    # ...
};
```

