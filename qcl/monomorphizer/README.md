# Monomorphizer

This module substitutes constant values and types in polymorphic sub-modules,
producing a monomorphic AST (mast).

Note that this produces considerable bloat. 
Reckless allocation can significantly degrade performance.
We would like to allocate our AST nodes as tightly together as possible.
Thus, on each subsequent pass, the CPU caches a few streams of memory in a 
linear-scan fashion.

Note that this requires incrementally evaluating constants in the program.
This is because we would like to generate new monomorphs of polymorphic modules
only when required. 
Thus, we must evaluate compile-time constants used as template arguments to
cache and substitute.

Since Python is a poor fit for the above two tasks, the bulk of this 
functionality is implemented in C++.

Cython wrappers (for Python) are provided to...
1. initiate copying (cf `copier.pyx`) with substitutions applied
2. query results (cf `mast.pyx`) once output is generated

## What is `extension`?

Since the monomorphizer requires a lot of brute-force compute and benefits from
low-level memory management, we would like to write it in C++.

The `extension` subdirectory contains this C++ source code, and handles
a lowered version of the Python AST, already checked for correctness.

This C++ code is **then built into a library called `ExtensionLib`** that is
then dynamically linked against each wrapper.

This ensures that only one copy of the extension is resident in memory at once,
and prevents odd behavior when global variables are cloned.

NOTE: since this library is statically linked with the wrapper, symbols in C++
will only update in Python-land when Cython detects the linked Python extension module,
`wrapper.pyx`, has changed.

## Usage

- create `template` instances for each sub-module
  - monomorphic modules have 0 args.
  - polymorphic modules have >0 args.

- replace each polymorphic template reference with a new monomorphic reference
  - when a polymorphic template ID reference is encountered,
  - we evaluate each expression argument (type-specs are constant)
  - then search cache to see if a MonoTemplateID was already generated by sub
  - then generate a MonoTemplateID by copy/sub

- to perform substitution,
  - for each `BoundVarGDefID`, simply generate a new `ConstGDefID` mapped to the
    argument value.


## Scratch TODO

- ~~first, finish implementing GDefID~~
- ~~next, implement substitution objects~~
  - these must be mutable, since we can use it as a cache to store partially
    evaluated polymorphs to substitute IDs over several instantiations
  - these just map GDefIDs to TOT_CONST GDefIDs
- ~~next, implement `mtype`~~
  - skipped this earlier, can be done now
- next, implement `rewrite` (aka sub&copy)
  - copy polymorphic body AST nodes into the polymorph
  - in fact, evaluate each field into a TOT_CONST such that its unique value is
    known at compile-time
  - when an ID is encountered, try to replace its GDefID with one in the sub map.
  - **WIP**: `monomorphize` ready, `eval` in progress.
- finally, implement MAST building from Python (see below)

## Interface

The core conceit is that we create monomorphic modules, and then apply 
substitutions to rewrite polymorphic bodies until they are truly monomorphic.
- every ID reference is assumed to be monomorphic

In `typer.definition.BaseRec`, there is a `def_id` field that is generated for 
each definition.

This can be accessed by a direct reference from 
`ast.{IdExp|IdTypeSpec}` to the `BaseRec` it references 
(as determined in typer).

When building MAST code from AST, we can query this `PyGDefID` which is different
than the extension's native `GDefID`.

TODO: 
implement `PyGDefID` and `GDefID` separation such that `std::map`s act as scoped 
symbol tables/frames for evaluation.
