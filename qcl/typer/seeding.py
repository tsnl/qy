"""
Seeding is the first typer pass.
It enables us to type symbols in files in any order by defining every global symbol using a free type variable.
This free type variable is called a seed.
Each seed can later be eliminated (substituted out) by applying rules of inference and unification (see inference).

Thus, this module creates seeds, creates global contexts in which to store (define) these seeds, and exports attributes
using associative maps to help retrieve contexts to retrieve seeds.
"""


import typing as t

from qcl import ast
from qcl import frontend
from qcl import type
from qcl import excepts
from qcl import feedback

from . import scheme
from . import context
from . import definition
from . import names


mod_context_map: t.Dict[ast.node.BaseModExp, context.Context] = {}
mod_exp_tid_map: t.Dict[ast.node.BaseModExp, type.identity.TID] = {}
mod_tid_exp_map: t.Dict[type.identity.TID, ast.node.BaseModExp] = {}


def seed_project_types(
        root_context: context.Context,
        project: frontend.Project,
        all_file_module_list: t.List[ast.node.FileModExp]
):
    """
    this pass creates `FreeVar` types for each module (called 'seeds') and associates AST nodes with other properties.
    For sub-modules, `BoundVar` is used for each template arg and must be substituted out by a scheme before use.
    :param project: the project whose definitions to seed
    :param root_context: the context manager to use to generate a tree of contexts [aka scopes].
    :param all_file_module_list: a list of all discovered FileModuleExp nodes.
    """

    # creating and storing a 'seed' FreeVar for each file-mod-exp:
    #   - this way, seeded imports can use any file-mod-exp's TID instead of an alias.
    for file_mod_exp in all_file_module_list:
        file_mod_tid = type.new_free_var(f"seed.file-mod[{file_mod_exp.source.file_path_rel_cwd}]")
        mod_exp_tid_map[file_mod_exp] = file_mod_tid
        mod_tid_exp_map[file_mod_tid] = file_mod_exp

    for file_module_exp in all_file_module_list:
        seed_file_mod_exp(root_context, file_module_exp)


def seed_file_mod_exp(root_ctx: context.Context, file_mod_exp: ast.node.FileModExp):
    # getting the seed for this file-mod-exp:
    file_mod_tid = mod_exp_tid_map[file_mod_exp]

    # NOTE:
    # We can access file modules using relations generated by the front-end, but sub-modules must be accessed via
    # context lookups.
    # This means we MUST DEFINE SUB-MODULES IN A PER-FILE-MODULE CONTEXT.
    file_mod_ctx = root_ctx.push_context(f"seed.file_mod[{file_mod_exp.source.file_path_rel_cwd}](tid={file_mod_tid})")

    # creating a seed free-var for each import that can be unified with an import later:
    for import_mod_name, import_mod_source in file_mod_exp.imports_source_map_from_frontend.items():
        assert isinstance(import_mod_source, frontend.FileModuleSource)
        seed_import(file_mod_ctx, file_mod_exp.loc, import_mod_name, import_mod_source)

    # creating an appropriate FreeVar for each sub-mod-exp:
    for sub_mod_name, sub_mod_exp in file_mod_exp.sub_module_map.items():
        seed_sub_mod_exp(file_mod_ctx, sub_mod_name, sub_mod_exp)

    # Closing all define operations & storing the context in cache:
    # TODO: check if this is required by `inference`, otherwise can be cut (only store contexts for sub-mods)
    mod_context_map[file_mod_exp] = file_mod_ctx

    # NOTE:
    # Even if this sub-mod accepts template args, we can substitute for a `Module` type with monomorphic fields whose
    # types depend on Bound Vars.
    # These can then be substituted out by template instantiations. Otherwise, they generate errors.


def seed_import(ctx: context.Context, loc, import_name: str, import_source: frontend.FileModuleSource):
    imported_mod_exp = import_source.ast_file_mod_exp_from_frontend
    imported_tid = mod_exp_tid_map[imported_mod_exp]
    def_obj = definition.ModRecord(loc, scheme.Scheme(imported_tid), imported_mod_exp)
    def_ok = ctx.try_define(import_name, def_obj)
    if not def_ok:
        msg_suffix = f"import name {import_name} clashes with existing definition in this file-module"
        raise excepts.TyperCompilationError(msg_suffix)


def seed_sub_mod_exp(ctx: context.Context, sub_mod_name: str, sub_mod_exp: ast.node.SubModExp):
    # creating and storing a 'seed' for this sub-mod-exp:
    sub_mod_tid = type.new_free_var(f"seed.sub_mod.{sub_mod_name}")
    mod_exp_tid_map[sub_mod_exp] = sub_mod_tid
    mod_tid_exp_map[sub_mod_tid] = sub_mod_exp

    # defining this sub-mod in the parent context (aka the file-mod):
    # - NOTE: we create a scheme that binds all template arg types.
    # - NOTE: all value template args do not need a polymorphic type variable.
    template_type_arg_names, template_val_arg_names = names.sift_type_from_val(sub_mod_exp.template_arg_names)
    sub_mod_scheme = scheme.Scheme(sub_mod_tid, template_type_arg_names)
    sub_mod_def_obj = definition.ModRecord(sub_mod_exp.loc, sub_mod_scheme, sub_mod_exp)
    def_ok = ctx.try_define(sub_mod_name, sub_mod_def_obj)
    if not def_ok:
        msg_suffix = f"sub-module {sub_mod_name} conflicts with another definition in a file-module scope"
        raise excepts.TyperCompilationError(msg_suffix)

    # NOTE: by spec, modules cannot be defined in sub-modules.
    #   this means no further recursion is necessary to discover more sub-modules.
    #   However, we still need to seed the module's contents.

    # Pushing a context for this sub-module's bound symbols:
    sub_mod_ctx = ctx.push_context(f"sub_mod.{sub_mod_name}")

    # Defining each value template arg in this context:
    for template_val_arg_name in template_val_arg_names:
        seed_template_val_arg(sub_mod_ctx, sub_mod_exp.loc, template_val_arg_name)

    # Defining each type template arg USING THE BoundVar INSTANCES in `sub_mod_scheme`
    for template_type_arg_name, bound_var in zip(template_type_arg_names, sub_mod_scheme.bound_vars):
        seed_template_type_arg(sub_mod_ctx, sub_mod_exp.loc, template_type_arg_name, bound_var)

    # Defining each bound ID in this context:
    for elem in sub_mod_exp.table.ordered_value_imp_bind_elems:
        assert isinstance(elem, ast.node.BaseBindElem)
        seed_bind1_elem(sub_mod_ctx, elem)

    # Closing all define operations & storing the context in cache:
    mod_context_map[sub_mod_exp] = sub_mod_ctx


def seed_template_val_arg(sub_mod_ctx: context.Context, loc: feedback.ILoc, template_val_arg_name: str):
    value_tid = type.new_free_var(f"seed.template_val_arg.{template_val_arg_name}")
    def_obj = definition.ValueRecord(loc, value_tid)
    def_ok = sub_mod_ctx.try_define(template_val_arg_name, def_obj)
    if not def_ok:
        msg_suffix = (
            f"template arg {template_val_arg_name} conflicts with another definition in this sub-module scope."
        )
        raise excepts.TyperCompilationError(msg_suffix)


def seed_template_type_arg(
        sub_mod_ctx: context.Context, loc: feedback.ILoc,
        template_type_arg_name: str, bound_var_tid: type.identity.TID
):
    def_obj = definition.TypeRecord(loc, bound_var_tid)
    def_ok = sub_mod_ctx.try_define(template_type_arg_name, def_obj)
    if not def_ok:
        msg_suffix = (
            f"template arg {template_type_arg_name} conflicts with another definition in this sub-module scope."
        )
        raise excepts.TyperCompilationError(msg_suffix)


def seed_bind1_elem(sub_mod_ctx: context.Context, bind1_elem: ast.node.BaseBindElem):
    # creating a 'seed':
    def_name = bind1_elem.id_name
    defined_tid = type.new_free_var(f"seed.bind.{def_name}")

    # creating an appropriate definition object `def_obj`:
    def_universe = names.infer_def_universe_of(def_name)
    if def_universe == definition.Universe.Value:
        def_obj = definition.ValueRecord(bind1_elem.loc, defined_tid)
    elif def_universe == definition.Universe.Type:
        def_obj = definition.TypeRecord(bind1_elem.loc, defined_tid)
    else:
        raise NotImplementedError("Unknown universe for Bind1?Elem")

    # defining in the active context:
    def_ok = sub_mod_ctx.try_define(def_name, def_obj)
    if not def_ok:
        msg_suffix = f"element {def_name} conflicts with another definition in this sub-module scope."
        raise excepts.TyperCompilationError(msg_suffix)
