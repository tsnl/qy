import "filepath";  // import is like a cached include.

// NOTE: use `#<id>` for symbol codes/tags.
// NOTE: use ':' for top-level bindings, and '=' for bindings inside functions.
moduleID: #q4_eg1;

// **All types must be statically, manifestly, and monomorphically typed at the time of their creation.**
// However, types are anonymous and first-class objects, so they can be created with functions.
// Functions themselves are generic [? cf 'polynomial' below, maybe generic upto reification, finitely many variants].
// Currying is not supported explicitly [yet?].

// Use ':' to bind globals, and '=' to bind locals.
// NOTE: individual builtin scalars satisfy `ISlice` with a count of '1': this trick lets us broadcast easily while maintaining a single object tree.
// NOTE: interface instances are a fat pointer: one pointer to the instance data, one pointer to a virtual table for this specific interface generated by the type.
pub polynomial :: IScalar -> IScalar;
polynomial: x => {
    local x :: IScalar;
    (x0, x1, x2, x3): (1, x, x*x, x*x*x);
    +x3*4 +x2*0 -x1*1 - x0*0
};

Vector: (T, n) => Array(T, n);
Vec3f: Vector(Float32, 3);
v: polynomial(IScalar(4));
v4: polynomial(Array(Float32, 4){1, 2, 3, 4});

// array arithmetic operators support NumPy-like broadcasting.
// methods are type-overloadable even by refined type.
w: polynomial(Vec3f(0.0f));

// NOTE: use `::` as context-dependent `isa` expression.
// NOTE: `this` and `This` are keywords
IScalar: interface (this :: This) {
    requires {
        this.mulInPlace :: mut This -> This -> Void;
        this.divideInPlace :: mut This -> This -> Void;
        This.mulIdentity :: Scalar;
    } for {
        this.mul :: This -> This -> This;
        this.div :: This -> This -> This;
        this.mulInverse :: This -> This;
    };
    this.mul: other => {
        this.mulInPlace(other);
        this
    };
    this.div: other => {
        this.divideInPlace(other);
        this
    };
    this.mulInverse: This.mulIdentity.div(this);
};
IVector: (T, n) => interface (this :: This) {
    // NOTE: `requires...for` must come first.
    requires {
        T :: IScalar;
        this.lengthSquared :: mut This -> () -> T;
        this.scale :: mut This -> T -> ();
    } for {
        This.dim :: Int32;
        this.length :: () -> T;
    };
    
    // NOTE: 'this' is implicitly in context based on above defs.
    this.dim: n;
    this.length: () => { this.lengthSquared().sqrt() };
};

// TODO: can implement this generically! Cover more of the `Vector T n` space.
impl Float32 :: IScalar using (this :: This) {
    // NOTE: we can inject the static constant 'mulIdentity' for even builtins like 'Float32'
    This.mulIdentity: 1.0f;
    
    // NOTE: we can invoke messages on builtins like Float32 (though no dynamic dispatch unless
    // via 'interface' like Go)
    this.mulInPlace: scalar => { this *= scalar; };
};
impl Vec3f :: IVector(Float32, 3) using (this :: This) {
    this.lengthSquared: () => { this[0]*this[0] + this[1]*this[1] * this[2]*this[2] };
    this.scale: () => { 
        this[0].scale(this.length().mulInverse());
        this[1].scale(this.length().mulInverse());
        this[2].scale(this.length().mulInverse());
    };
};

// FINALLY
//  - do types obey structural equality? How to break out of this if required?
//  - better idea: separate '==' from 'is', and allow the user to treat types as first-class objects.
//    - TL;DR: make sure language is identity-independent/works in a nominal type system.
