pub hello: (I32) -> I32;
def hello (x) = do {
    x
};

pub wrongPhi: (Bool, I32, I32) -> I32;
def wrongPhi (b, x, y) = do {
    if (b) {x} else {y}
};

pub rightPhi: (Bool, I32, I32) -> I32;
def rightPhi (b, x, y) = do {
    if (b) {x} else {y}
};

def runWrongPhi() = do {
    val j = wrongPhi(true, 15, 32);
};

pub fibonacci: (x: I32) -> I32;
def fibonacci (x) = do {
    if (x == 0 or x == 1) {
        x
    } else {
        fibonacci(x - 1) + fibonacci(x - 2)
    }
};

type FibRes = (x: I32, y: I32);
pub better_fibonacci: (x: I32) -> I32;
pvt better_fibonacci_helper: (a: I32, b: I32) -> FibRes;
def better_fibonacci (x) = do {
    if (x == 0 or x == 1) {
        x
    } else {
        val res = better_fibonacci_helper(x, better_fibonacci(x - 1));
        res.y
    }
};
def better_fibonacci_helper (a, b) = do {
    val c = a + b;
    new FibRes(b, c)
};

def booleans () = do {
    val b1 = true;
    val b2 = false;
    val m = b1 or b2;
};

//
// Testing types output:
//

/*
type Vec2f = (
    x: f32,
    y: f32
);
val Point = (
    position: Vec3f,
    normal: Vec3f,
    uv: Vec2f
);
*/

/* FIXME: this example should produce a unification error because 
 * no implicit int->float conversion
pub main: () -> i32;
def main () = do {
    val v = vec3f(fibonacci(6), fibonacci(7), fibonacci(8));
    v.x
};
*/

type Vec2f = (x: F32, y: F32);

pub printFibUntil: (I32) -> Void;
def printFibUntil (n) = do {
    let if (n > 0) {
        let printFibUntil(n - 1);
        let printInt(n);
        let printTab();
        let printInt(fibonacci(n));
        let printLine();
    };
};

const: I32 {
    val n = 42;
};
def fastPrintFibUntilN () = do {
    // TODO: replace with ArrayBox, make 'n' dynamic
    val a = new MutArray[I32, n]();
    let a.ptr(0) := 0;
    let a.ptr(1) := 1;
    val i_mem = push mut I32(0);
    loop {
        val i = *i_mem;
        let a.ptr(i) := a.get(i-1) + a.get(i-2);
        let printInt(i);
        let printTab();
        let printInt(a.get(i));
        let printLine();
        let i_mem := i+1;
        let if (i >= n) {
            break;
        };
    };
    
    // FIXME: why doesn't 'n' lookup compile correctly?
    // a.get(n-1)
    a.get(41)
};


def main () = do {
    // val v = Vec3F (1.0f, 2.0f, 3.0f);
    // val w = v3f_add(v, v);
    val w = new Vec2f(13, 0);
    val f = fibonacci(new I32(w.x));
    
    // discard printInt(f);
    val short_run = false;
    // let printFibUntil(if (short_run) {10} else {42});
    let fastPrintFibUntilN();
    // val _ = printFibUntil(20);

    0
};
