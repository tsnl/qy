// FIXME: currently disabled

// Qy is a programming language ideal for prototyping quickly.
//   - it uses the C type system with a few enhancements and RTTI.
//   - type specifiers are only needed for functions and type definitions.
//   - it uses a single-pass compiler for simplicity

// typing/declarations:
// NOTE: argument names are optional, but types are mandatory
// NOTE: functions do not need to be declared before definition unless...
//   1. they are used before they are defined, or
//   2. they are marked as 'public' (in which case declaration goes in a header)
pub vec3f: (x: f32, y: f32, z: f32) => Vec3f;
pub v3f_add: (Vec3f, Vec3f) => Vec3f;
pub v3f_scale: (Vec3f, f32) => Vec3f;

// enums provided using 'const', which translates into preprocessor declarations
const i32 {
    let errorCode_allOK = 0;
    let errorCode_badCliArgs = 1 + __prev_const__;
    let errorCode_badFilePath = 1 + __prev_const__;
    let errorCode_detectedRuntimeError = 1 + __prev_const__;
};
const u32 {
    let windowFlag_fullScreen = 0x1u;
    let windowFlag_fixedSize = 2u * __prev_const__;
    let windowFlag_hwAccelerated = 2u * __prev_const__;
};

// struct definitions: (enum, union are similar)
def Point = struct {
    pos: Vec3f
};
def Vec3f = struct {
    x: f32,
    y: f32,
    z: f32
};

// function definitions:
// NOTE: type inference fills in holes.
def vec3f (x, y, z) = 
    Vec3f(x, y, z);

def v3f_add (v1, v2) {
    let vx = v1.x + v2.x;
    let vy = v1.y + v2.y;
    let vz = v1.z + v2.z;
    return vec3f(vx, vy, vz);
};
def v3f_scale (v, s) {
    let sx = v.x * s;
    let sy = v.y * s;
    let sz = v.z * s;
    return vec3f(sx, sy, sz);
};
