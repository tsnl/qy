pub hello: (I32) -> I32;
let hello (x) = {
    return x;
};

pub wrongPhi: (Bool, I32, I32) -> I32;
let wrongPhi (b, x, y) = {
    if b {
        return x;
    } else {
        return y;
    };
};

let j = wrongPhi(true, 15, 32);

let fibonacci (x) = {
    if x == 0 {
        return 0;
    } else if x == 1 {
        return 1;
    } else {
        return fibonacci(x - 1) + fibonacci(x - 2);
    };
};

let b1 = true;
let b2 = false;
let m = b1 or b2;

//
// Testing types output:
//

/*
let Vec3f = struct {
    x: f32,
    y: f32,
    z: f32
};
let Vec2f = struct {
    x: f32,
    y: f32
};
let Point = struct {
    position: Vec3f,
    normal: Vec3f,
    uv: Vec2f
};
*/

/* FIXME: this example should produce a unification error because 
 * no implicit int->float conversion
pub main: () -> i32;
let main () = {
    let v = vec3f(fibonacci(6), fibonacci(7), fibonacci(8));
    return v.x;
};
*/

let Vec2f = struct {
    x: F32,
    y: F32
};

pub printFibUntil: (I32) -> Void;
let printFibUntil (n) = {
    if (n > 0) {
        discard printFibUntil(n - 1);
        discard printInt(n);
        discard printTab();
        discard printInt(fibonacci(n));
        discard printLine();
    };
};

let main () = {
    // let v = Vec3F (1.0f, 2.0f, 3.0f);
    // let w = v3f_add(v, v);
    let w = make Vec2f(13, 0);
    let f = fibonacci(make I32(w.x));
    // discard printInt(f);
    let short_run = true;
    discard printFibUntil(mux(short_run, 10, 42));
    // let _ = printFibUntil(20);

    for {
        break;
    };

    return 0;
};
