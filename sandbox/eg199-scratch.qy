pub hello: (i32)=>i32;
let hello (x) = {
    return x;
};

pub wrongPhi: (bool,i32,i32)=>i32;
let wrongPhi (b, x, y) = {
    if b {
        return x;
    } else {
        return y;
    };
};

let j = wrongPhi(true, 15, 32);

let fibonacci (x) = {
    if x == 0 {
        return 0;
    } else if x == 1 {
        return 1;
    } else {
        return fibonacci(x - 1) + fibonacci(x - 2);
    };
};

let b1 = true;
let b2 = false;
let m = b1 or b2;

//
// Testing types output:
//

/*
let Vec3f = struct {
    x: f32,
    y: f32,
    z: f32
};
let Vec2f = struct {
    x: f32,
    y: f32
};
let Point = struct {
    position: Vec3f,
    normal: Vec3f,
    uv: Vec2f
};
*/

/* FIXME: this example should produce a unification error
pub main: () => i32;
let main () = {
    let v = vec3f(fibonacci(6), fibonacci(7), fibonacci(8));
    return v.x;
};
*/

let Vec2f = struct {
    x: f32,
    y: f32
};

let main () = {
    // let v = Vec3f (1.0f, 2.0f, 3.0f);
    // let w = v3f_add(v, v);
    let w = new Vec2f(13, 0);
    return fibonacci(new i32(w.x));
};
