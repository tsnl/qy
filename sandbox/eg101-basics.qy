// Qy is a programming language ideal for prototyping quickly.
//   - it uses the C type system with a few enhancements and RTTI.
//   - type specifiers are only needed for functions and type definitions.
//   - it uses a single-pass compiler for simplicity

// typing/declarations:
// NOTE: argument names are optional, but types are mandatory
// NOTE: functions do not need to be declared before definition unless...
//   1. they are used before they are defined, or
//   2. they are marked as 'public' (in which case declaration goes in a header)
pub vec3f: (x: F32, y: F32, z: F32) -> Vec3F;
pub v3f_add: (Vec3F, Vec3F) -> Vec3F;
pub v3f_scale: (Vec3F, F32) -> Vec3F;

// enums provided using 'const', which translates into preprocessor declarations
const I32 {
    let EC_ALL_OK = 0;
    let EC_BAD_CLI_ARGS = 1 + $predecessor;
    let EC_BAD_FILE_PATH = 1 + $predecessor;
    let EC_DETECTED_RUNTIME_ERROR = 1 + $predecessor;
};
const U32 {
    let WINDOW_FLAG_FULLSCREEN = 0x1u;
    let WINDOW_FLAG_FIXED_SIZE = 2u * $predecessor;
    let WINDOW_FLAG_HARDWARE_ACCELERATED = 2u * $predecessor;
};

// struct definitions: (enum, union are similar)
let Point = struct { pos: Vec3F };
let Vec3F = struct { x: F32, y: F32, z: F32 };

// function definitions:
// NOTE: type inference fills in holes.
let vec3f (x, y, z) = make Vec3F(x, y, z);

let v3f_add (v1, v2) = {
    let vx = v1.x + v2.x;
    let vy = v1.y + v2.y;
    let vz = v1.z + v2.z;
    return vec3f(vx, vy, vz);
};
let v3f_scale (v, s) = {
    let sx = v.x * s;
    let sy = v.y * s;
    let sz = v.z * s;
    return vec3f(sx, sy, sz);
};
