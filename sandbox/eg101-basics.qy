// Qy is a programming language ideal for prototyping quickly.
//   - it uses the C type system with a few enhancements and RTTI.
//   - type specifiers are only needed for functions and type definitions.
//   - it uses a single-pass compiler for simplicity

// typing/declarations:
// NOTE: argument names are optional, but types are mandatory
// NOTE: functions do not need to be declared before definition unless...
//   1. they are used before they are defined, or
//   2. they are marked as 'public' (in which case declaration goes in a header)
pub vec3f: (x: F32, y: F32, z: F32) -> Vec3F;
pub v3f_add: (Vec3F, Vec3F) -> Vec3F;
pub v3f_scale: (Vec3F, F32) -> Vec3F;

// enums provided using 'const', which translates into preprocessor declarations
const I32 {
    val EC_ALL_OK = 0;
    val EC_BAD_CLI_ARGS = 1 + $predecessor;
    val EC_BAD_FILE_PATH = 1 + $predecessor;
    val EC_DETECTED_RUNTIME_ERROR = 1 + $predecessor;
};
const U32 {
    val WINDOW_FLAG_FULLSCREEN = 0x1u;
    val WINDOW_FLAG_FIXED_SIZE = 2u * $predecessor;
    val WINDOW_FLAG_HARDWARE_ACCELERATED = 2u * $predecessor;
};

// struct definitions: (enum, union are similar)
typ Point = (pos: Vec3F);
typ Vec3F = (x: F32, y: F32, z: F32);

// function definitions:
// NOTE: type inference fills in holes.
def vec3f (x, y, z) = {
    return make Vec3F(x, y, z);
};

def v3f_add (v1, v2) = {
    val vx = v1.x + v2.x;
    val vy = v1.y + v2.y;
    val vz = v1.z + v2.z;
    return vec3f(vx, vy, vz);
};
def v3f_scale (v, s) = {
    val sx = v.x * s;
    val sy = v.y * s;
    val sz = v.z * s;
    return vec3f(sx, sy, sz);
};
